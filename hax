var room = HBInit({
  roomName: "2Ô∏è‚É£üíé 4V4 IDA & VUELTA-PENALES üíé6Ô∏è‚É£",
  maxPlayers: 25,
  public: false,
  playerName: " ",
});

// ================= CONFIG TIEMPOS =================
var TIEMPO_REGLA = 120;
var EXTRAS_POSIBLES = [20, 25, 30];
var CUENTA_EXTRA = 3;
var DELAY_VUELTA_MS = 3000;

// ================= CHAT QUEUE =================
var chatQueue = [];
var chatRunning = false;
var CHAT_STEP = 0;
var YIELD_EVERY = 10;
var YIELD_MS = 15;

function qChat(line){ chatQueue.push(line); runChatQueue(); }
function qLines(lines){ for (let i=0;i<lines.length;i++) chatQueue.push(lines[i]); runChatQueue(); }

function runChatQueue(){
  if(chatRunning) return;
  chatRunning = true;
  let sent = 0;

  (function tick(){
    if(chatQueue.length === 0){ chatRunning = false; return; }
    room.sendChat(chatQueue.shift());
    sent++;
    setTimeout(tick, (sent % YIELD_EVERY === 0) ? YIELD_MS : CHAT_STEP);
  })();
}

function burstChat(line){ room.sendChat(line); }
function burstLines(lines){ for(let i=0;i<lines.length;i++) room.sendChat(lines[i]); }

function decoTop(){ return "‚ú®üåü‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêüåü‚ú®"; }
function decoBot(){ return "‚ú®üåü‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêüåü‚ú®"; }

// ================= PM (solo 1 jugador) + HELPERS =================
function pm(id, msg){
  // En HaxBall Headless: sendAnnouncement(msg, targetId, color, style, sound)
  try { room.sendAnnouncement(msg, id, 0xFFFFFF, 0, 0); }
  catch(e){ try{ room.sendChat(msg); }catch(_){} }
}
// ================= BIENVENIDA (3 MENSAJES EXPLICANDO TODO) =================
var bienvenidaCooldown = {};
var BIENVENIDA_CD_MS = 90000;

function isNewAccount(player){
  return !player || !player.auth || player.auth.length < 5;
}

function sendBienvenida3(player){
  if(!player) return;

  let auth = player.auth || ("noauth_" + player.id);
  let now = Date.now();


  pm(player.id, decoTop());
  pm(player.id, "‚öΩ MODO: 4V4 COMPETITIVO");
  pm(player.id, "üíé Econom√≠a  (monedas cuentan).");
  pm(player.id, "üìå Serie: IDA & VUELTA + PENALES si GLOBAL empata.");
  pm(player.id, "üÜò Comandos: !help | !ida | !global | !stats \"Nombre\"");
  pm(player.id, decoBot());

  pm(player.id, decoTop());
  pm(player.id, "üí∞ MONEDAS (guardadas por AUTH)");
  pm(player.id, "‚úÖ Inicial: 10 monedas");
  pm(player.id, "üèÅ Ganancias:");
  pm(player.id, "‚Ä¢ Gol: +1");
  pm(player.id, "‚Ä¢ Ganar partido: +3");
  pm(player.id, "‚Ä¢ Empate: +2");
  pm(player.id, "‚Ä¢ MVP: +4");
  pm(player.id, "‚ö†Ô∏è El x2 NO aplica en apuestas.");
  pm(player.id, decoBot());

  pm(player.id, decoTop());
  pm(player.id, "üé≤ APUESTAS (solo a TU equipo)");
  pm(player.id, "‚ùå Prohibido apostar contra tu team");
  pm(player.id, "‚úÖ Min: 1 moneda");
  pm(player.id, "‚úÖ Max: Team 3 | Empate 2");
  pm(player.id, "üìà Cuotas: Team x1.8 | Empate x3 (redondeo ‚Üì)");
  pm(player.id, "‚õî Se CIERRAN apuestas:");
  pm(player.id, "‚Ä¢ a los 10s de iniciar el partido");
  pm(player.id, "‚Ä¢ o cuando hay 1er gol");
  pm(player.id, "üõí TIENDA: power, +tiempo, -tiempo rival, caja random, votekick, voteban, ban perm.");
  pm(player.id, "üö´ ANTI-ABUSO: 1 jugador/IP en cancha | no vender partidos");
  pm(player.id, decoBot());

  if(isNewAccount(player)){
    pm(player.id, "‚ö†Ô∏è CUENTA NUEVA: DESPUES DE 3M. PORDRAS USAR APUESTAS");
  }
}

function fmtTime(sec){
  sec = Math.max(0, sec|0);
  let m = Math.floor(sec/60), s = sec%60;
  return m + ":" + (s<10?"0":"") + s;
}

function findPlayerByNameLoose(name){
  let list = room.getPlayerList();
  let exact = list.find(p => p.name === name);
  if(exact) return exact;

  let low = (name||"").toLowerCase().trim();
  if(!low) return null;

  let eq = list.find(p => (p.name||"").toLowerCase() === low);
  if(eq) return eq;

  return list.find(p => (p.name||"").toLowerCase().includes(low)) || null;
}

// ================= COMANDOS (TODOS) =================
function cmdHelp(targetId){
  pm(targetId, "üìå COMANDOS DISPONIBLES:");
  pm(targetId, "‚Ä¢ !help");
  pm(targetId, "‚Ä¢ !ida");
  pm(targetId, '‚Ä¢ !stats "Nombre"');
  pm(targetId, "‚Ä¢ !global");
  pm(targetId, "‚Ä¢ !arquero / !noarquero  (solo si el GLOBAL empata)");
  pm(targetId, '‚Ä¢ CAPITANES: !cambio "Sale" "Entra" (1 por serie)');
  pm(targetId, '‚Ä¢ ADMIN: !on / !off | !capitan "Nombre" | !nocapitan "Nombre" | !penal');
}

function cmdIda(targetId){
  let sc = room.getScores();

  // si la IDA est√° en juego ahora mismo
  if(sc && fase === "IDA"){
    pm(targetId, `üü¶ IDA (EN JUEGO): üîµ ${sc.blue} - ${sc.red} üî¥ | ‚è±Ô∏è ${sc.time}s`);
    return;
  }

  // si ya termin√≥ la IDA (guardado)
  if(idaTermino){
    pm(targetId, `üü¶ IDA (FINAL): üîµ ${idaScore.blue} - ${idaScore.red} üî¥`);
    return;
  }

  pm(targetId, "üü¶ IDA a√∫n no se jug√≥.");
}

function cmdGlobal(targetId){
  if(!sistemaActivo){
    pm(targetId, "‚ö†Ô∏è No hay serie activa.");
    return;
  }
  let A = serieGoals[1] || 0;
  let B = serieGoals[2] || 0;

  pm(targetId, decoTop());
  pm(targetId, "üåç GLOBAL (GOLES REALES)");
  pm(targetId, `${serieLabel[1]} ${A} ‚îÄ ${B} ${serieLabel[2]}`);
  pm(targetId, `üìå Fase: ${fase}`);
  pm(targetId, decoBot());
}

function cmdStats(targetId, name){
  if(!name || !name.trim()){
    pm(targetId, 'Uso: !stats "Nombre"');
    return;
  }

  let p = findPlayerByName(name) || findPlayerByNameLoose(name);
  if(!p){
    pm(targetId, `‚ùå No encuentro a "${name}" (debe estar conectado).`);
    return;
  }

  let id = p.id;

  pm(targetId, `üìä ${p.name} | ‚öΩ ${goles[id]||0} | üéÅ ${asistencias[id]||0} | üòµ ${autogoles[id]||0} | ‚è±Ô∏è ${fmtTime(tiempo[id]||0)}`);
  pm(targetId, `Partido | ‚öΩ ${golesPartido[id]||0} | üéÅ ${asistPartido[id]||0} | üòµ ${ogPartido[id]||0} | ‚è±Ô∏è ${fmtTime(tiempoPartido[id]||0)}`);
}

// ================= UTIL =================
function parseArgs(msg){
  // soporta: !cmd a b | !cmd "nombre con espacios" "otro nombre"
  let re = /"([^"]+)"|'([^']+)'|(\S+)/g;
  let out = [], m;
  while((m = re.exec(msg)) !== null) out.push(m[1] || m[2] || m[3]);
  return out;
}
function findPlayerByName(name){
  return room.getPlayerList().find(p => p.name === name) || null;
}
function getNameById(id){
  let p = room.getPlayerList().find(x => x.id === id);
  return p ? p.name : ("ID " + id);
}
function setAvatarSafe(id, avatar){
  try{
    room.setPlayerAvatar(id, avatar || "");
  }catch(e){}
}

// ================= TIME MULTIPLIER =================
var timeMultiplier = 1; // 1 = normal

// ================= ESTADO =================
var sistemaActivo = false;
var fase = "IDA";
var idaScore = { blue: 0, red: 0 };
var bloqueo = false;
var enPausa = false;
var idaTermino = false; // ‚úÖ para !ida

var lastScore = { blue: 0, red: 0, time: 0 };
var lastScoreValido = false;

var vueltaConEquiposInvertidos = false;

// ‚úÖ Penales solo si GLOBAL empata
var penalesHabilitados = false;

// ‚úÖ Identidad real de la serie (para global sin confusi√≥n)
var serieTeamOf = {};        // playerId -> 1 o 2 (equipos del momento de !on)
var serieGoals = {1:0, 2:0}; // goles globales por equipo real
var serieLabel = {1:"üî¥ ROJO (IDA)", 2:"üîµ AZUL (IDA)"}; // nombres para mostrar

// ================= CAPITANES + CAMBIOS =================
// 1 = ROJO (real), 2 = AZUL (real)
var capitan = { 1: null, 2: null };        // id del capit√°n por equipo REAL
var cambioUsado = { 1: false, 2: false };  // 1 cambio por equipo por serie

function realToPhysicalTeam(realTeam){
  // cuando ya estamos en VUELTA (swap aplicado), lo f√≠sico est√° invertido
  return vueltaConEquiposInvertidos ? (realTeam === 1 ? 2 : 1) : realTeam;
}

// ‚úÖ IMPORTANTE: durante "bloqueo" (transici√≥n IDA->VUELTA) A√öN NO se aplic√≥ swapEquipos.
// En ese momento, aunque vueltaConEquiposInvertidos ya est√© true, los equipos f√≠sicos siguen siendo de IDA.
function realToPhysicalTeamNow(realTeam){
  if(vueltaConEquiposInvertidos && bloqueo) return realTeam; // todav√≠a en layout IDA
  return realToPhysicalTeam(realTeam);
}

// conversi√≥n f√≠sica->real (considerando el mismo caso especial de bloqueo)
function physicalToRealTeamNow(physicalTeam){
  if(physicalTeam === 0) return 0;
  if(vueltaConEquiposInvertidos && bloqueo) return physicalTeam; // todav√≠a en layout IDA
  return vueltaConEquiposInvertidos ? (physicalTeam === 1 ? 2 : 1) : physicalTeam;
}

function captainRealTeamOfPlayer(p){
  if(p.id === capitan[1]) return 1;
  if(p.id === capitan[2]) return 2;
  return 0;
}

function setCaptain(realTeam, playerId){
  if(capitan[realTeam] && capitan[realTeam] !== playerId){
    try{ room.setPlayerAvatar(capitan[realTeam], ""); }catch(e){}
  }
  capitan[realTeam] = playerId;
  try{ room.setPlayerAvatar(playerId, "üß¢"); }catch(e){}
}

function clearCaptain(realTeam){
  if(capitan[realTeam]){
    try{ room.setPlayerAvatar(capitan[realTeam], ""); }catch(e){}
  }
  capitan[realTeam] = null;
}

function moveRealTeamToSpec(realTeam){
  room.getPlayerList().forEach(p=>{
    if(p.team !== 0 && serieTeamOf[p.id] === realTeam){
      room.setPlayerTeam(p.id, 0);
    }
  });
}

// ================= CONTROL EXTRA =================
var extraEnCuenta = false;
var extraActivo = false;
var extraBase = 0;
var extraReal = 0;
var extraEndTime = 0;

// ================= STATS (global) =================
var goles = {}, asistencias = {}, autogoles = {}, tiempo = {}, racha = {};
var ultimoGol = null, ultimoTocador = null, penultimoTocador = null;
var ultimoTocadorTime = 0, penultimoTocadorTime = 0;

var jugoIda = new Set(), jugoVuelta = new Set();

// ================= STATS (por partido para MVP) =================
var golesPartido = {}, asistPartido = {}, ogPartido = {}, tiempoPartido = {};

// ================= CAMISETAS =================
function ponerCamisetas() {
  room.setTeamColors(1, 1, 0x0033A0, [0xFFFFFF], 90);
  room.setTeamColors(2, 0, 0xF5F5DC, [0x8B0000], 0);
}

// ================= NARRACI√ìN =================
var narracionesGol = [
  "‚öΩüî• GOOOOLAZO de {p}", "üöÄ Misil imparable de {p}", "üéØ Definici√≥n perfecta de {p}",
  "üí• Remate letal de {p}", "üß† Gol inteligente de {p}", "‚ö°  AQQ Rayo al arco de {p}",
  "ü•∂ Frialdad total de {p}", "üéâ Explota el estadio, gol de {p}"
];
function narrarGol(nombre) {
  var frase = narracionesGol[Math.floor(Math.random()*narracionesGol.length)];
  room.sendChat(frase.replace("{p}", nombre));
}
function anunciarGolesEspecialesPorPartido(nombre, n){
  if(n === 6) room.sendChat(`üíé‚öΩ SEXTETE BESTIAL de ${nombre}! (6)`);
  if(n === 7) room.sendChat(`üö®‚öΩ‚öΩ‚öΩ LOCURA TOTAL: ${nombre} lleva 7 GOLES!`);
  if(n === 8) room.sendChat(`üëëüî• HIST√ìRICO: ${nombre} METI√ì 8 GOLES!!!`);
}

// ================= CUENTA REGRESIVA (3s) =================
function cuentaRegresiva3(cb) {
  qLines(["‚è≥ 3...", "‚è≥ 2...", "‚è≥ 1..."]);
  setTimeout(()=>{ if(cb) cb(); }, 900);
}

// ================= CAMBIO DE ARCO (SWAP EQUIPOS) =================
function swapEquipos(){
  let players = room.getPlayerList();
  players.forEach(p=>{
    if(p.team === 1) room.setPlayerTeam(p.id, 2);
    else if(p.team === 2) room.setPlayerTeam(p.id, 1);
  });
}
function randomPlayerFromSerieTeam(teamReal){
  let players = room.getPlayerList().filter(p => p.team !== 0);
  let pool = players.filter(p => serieTeamOf[p.id] === teamReal);
  if(pool.length === 0) return null;
  return pool[Math.floor(Math.random()*pool.length)];
}

// ================= MVP =================
function MVPFromMaps(ids, titulo, gMap, aMap, tMap, ogMap, instant){
  if(!ids || ids.length === 0) return;

  ids = ids.filter(id => room.getPlayerList().some(p=>p.id===id) || true);
  ids.sort((a,b)=>
    (gMap[b]||0)-(gMap[a]||0) ||
    (aMap[b]||0)-(aMap[a]||0) ||
    (tMap[b]||0)-(tMap[a]||0)
  );

  let topId = ids[0];
  let p = room.getPlayerList().find(x=>x.id===topId) || {name: `ID ${topId}`};

  let g = (gMap[topId]||0);
  let a = (aMap[topId]||0);
  let og = (ogMap[topId]||0);

  let lines = [
    decoTop(),
    "üèÜ " + titulo,
    "üëë " + p.name,
    "‚öΩ Goles: " + g + " | üéÅ Asistencias: " + a,
    "üòµ Autogoles: " + og,
    decoBot()
  ];

  if(instant) burstLines(lines);
  else qLines(lines);
}

function MVP_IDA(){ MVPFromMaps([...jugoIda], "MVP DE LA IDA", golesPartido, asistPartido, tiempoPartido, ogPartido, false); }
function MVP_VUELTA(){ MVPFromMaps([...jugoVuelta], "MVP DE LA VUELTA", golesPartido, asistPartido, tiempoPartido, ogPartido, true); }
function MVP_SERIE(){ MVPFromMaps(Object.keys(goles).map(Number), "MVP DE LA SERIE", goles, asistencias, tiempo, autogoles, true); }

// ================= RESET PARTIDO =================
function resetPorPartido(){
  extraEnCuenta = false;
  extraActivo = false;
  extraBase = 0;
  extraReal = 0;
  extraEndTime = 0;

  lastScoreValido = false;
  lastScore = { blue: 0, red: 0, time: 0 };

  ultimoTocador = null;
  penultimoTocador = null;
  ultimoTocadorTime = 0;
  penultimoTocadorTime = 0;

  golesPartido = {};
  asistPartido = {};
  ogPartido = {};
  tiempoPartido = {};
  ultimoGol = null;
  racha = {};
}

// ================= GAME START =================
room.onGameStart = function () {
  bloqueo = false;
  ponerCamisetas();
  resetPorPartido();

  // ‚úÖ Anunciar capitanes al iniciar (CAPITANES REALES)
  let capR = capitan[1] ? getNameById(capitan[1]) : "‚Äî";
  let capB = capitan[2] ? getNameById(capitan[2]) : "‚Äî";
  room.sendChat(`üß¢ CAPITANES | üî¥ ROJO: ${capR}  |  üîµ AZUL: ${capB}`);

  room.getPlayerList().forEach(p=>{
    if(p.team !== 0){
      if(fase==="IDA") jugoIda.add(p.id);
      if(fase==="VUELTA") jugoVuelta.add(p.id);
    }
  });
};

// ================= PAUSA =================
room.onGamePause = ()=> enPausa = true;
room.onGameUnpause = ()=> enPausa = false;

// ================= CONTADOR TIEMPO =================
setInterval(()=>{
  if(!sistemaActivo || bloqueo || enPausa) return;

  for(let i = 0; i < timeMultiplier; i++){
    room.getPlayerList().forEach(p=>{
      if(p.team!==0){
        tiempo[p.id] = (tiempo[p.id]||0) + 1;
        tiempoPartido[p.id] = (tiempoPartido[p.id]||0) + 1;

        if(fase==="IDA") jugoIda.add(p.id);
        if(fase==="VUELTA") jugoVuelta.add(p.id);
      }
    });
  }
},1000);

// ================= RECORDATORIO CAPITANES (PM cada 35s) =================
setInterval(()=>{
  if(!sistemaActivo || fase === "FIN") return;

  [1,2].forEach(rt=>{
    let capId = capitan[rt];
    if(!capId) return;

    // debe estar conectado
    let capP = room.getPlayerList().find(p=>p.id===capId);
    if(!capP) return;

    // si ya us√≥ cambio, no recordar
    if(cambioUsado[rt]) return;

    pm(capId, `üß¢ Capit√°n ${rt===1?"üî¥ ROJO":"üîµ AZUL"}: tienes 1 cambio ‚úÖ Usa: !cambio "Sale" "Entra" (si no pones Entra, entra espectador al azar)`);
  });
}, 35000);

// ================= TOQUES =================
room.onPlayerBallKick = p=>{
  if(p.team===0) return;

  // penales
  if(penalActivo){
    if(p.id === penShooterId){
      penShooterKickTime = Date.now();
      penKeeperTouched = false;

      lastBallPos = room.getBallPosition();
      lastBallMoveTime = Date.now();
    } else if(p.id === penKeeperId){
      if(penShooterKickTime > 0 && (Date.now() - penShooterKickTime) <= PENAL_TOUCH_WINDOW_MS){
        penKeeperTouched = true;
      }
    }
  }

  penultimoTocador = ultimoTocador;
  penultimoTocadorTime = ultimoTocadorTime;

  ultimoTocador = p;
  ultimoTocadorTime = Date.now();
};

// ================= GAME TICK =================
room.onGameTick = function(){
  if(penalActivo){
    penTryResolveMissByBall();
    return;
  }

  if(!sistemaActivo) return;

  let s = room.getScores();
  if(!s) return;

  lastScore.blue = s.blue;
  lastScore.red = s.red;
  lastScore.time = s.time;
  lastScoreValido = true;

  if(!extraActivo && !extraEnCuenta && s.time >= TIEMPO_REGLA / timeMultiplier){

    let diff = Math.abs(s.blue - s.red);

    if(diff >= 4){ room.stopGame(); return; }
    if(diff === 3 && Math.random() < 0.60){ room.stopGame(); return; }

    extraEnCuenta = true;
    room.pauseGame(true);

    qLines([decoTop(), "‚è±Ô∏è FIN DEL REGLAMENTARIO (" + TIEMPO_REGLA + "s)", "‚ö° TIEMPO EXTRA EN:", decoBot()]);

    cuentaRegresiva3(()=>{
      extraBase = EXTRAS_POSIBLES[Math.floor(Math.random()*EXTRAS_POSIBLES.length)];
      extraReal = extraBase + CUENTA_EXTRA;
      extraEndTime = TIEMPO_REGLA + extraReal;
      extraActivo = true;

      qLines([
        decoTop(),
        "‚ú® TIEMPO EXTRA",
        "‚ûï Base: " + extraBase + "s  |  ‚è≥ +" + CUENTA_EXTRA + "s = " + extraReal + "s",
        "üèÅ Termina en: " + extraEndTime + "s",
        decoBot()
      ]);

      room.pauseGame(false);
    });
  }

  if(extraActivo && s.time >= extraEndTime){
    room.stopGame();
  }
};

// ================= GOLES =================
room.onTeamGoal = function(team){
  // =============== PENALES ===============
  if(penalActivo){
    if(!penAttemptLive) return;
    penAttemptLive = false;

    let logicalKickTeam = penTurnTeam;
    let kickReal = mapTeam(logicalKickTeam);
    let defReal  = (kickReal === 1 ? 2 : 1);

    penShots[logicalKickTeam]++;

    let kp = penPlayerById(penKeeperId);
    let sp = penPlayerById(penShooterId);

    if(team === kickReal){
      penGoals[logicalKickTeam]++;
      penResolveAndNext(`‚úÖ GOL de ${sp ? sp.name : "el tirador"}!`);
    } else if(team === defReal){
      if(penKeeperTouched) penResolveAndNext(`üß§ ATAJ√ì ${kp ? kp.name : "el arquero"}!`);
      else penResolveAndNext(`‚ùå ERR√ì ${sp ? sp.name : "el tirador"}!`);
    } else {
      penResolveAndNext("‚ö†Ô∏è Resultado raro (fin del intento).");
    }
    return;
  }

  // =============== PARTIDO NORMAL ===============
  if(!sistemaActivo || !ultimoTocador) return;

  // Autogol
  if(ultimoTocador.team !== team){
    autogoles[ultimoTocador.id] = (autogoles[ultimoTocador.id]||0) + 1;
    ogPartido[ultimoTocador.id] = (ogPartido[ultimoTocador.id]||0) + 1;

    room.sendChat("üòµ AUTOGOL de " + ultimoTocador.name);

    let ogReal = serieTeamOf[ultimoTocador.id];
    if(ogReal === 1) serieGoals[2]++; else if(ogReal === 2) serieGoals[1]++;

    return;
  }

  // Gol normal
  let s = ultimoTocador;
  narrarGol(s.name);

  goles[s.id] = (goles[s.id]||0) + 1;

  golesPartido[s.id] = (golesPartido[s.id]||0) + 1;
  let gp = golesPartido[s.id];

  let realTeam = serieTeamOf[s.id];
  if(realTeam === 1) serieGoals[1]++; else if(realTeam === 2) serieGoals[2]++;

  if(gp === 3) room.sendChat(`üé©‚öΩ HATTRICK de ${s.name}!`);
  if(gp === 4) room.sendChat(`üî•‚öΩ P√ìKER de ${s.name}!`);
  if(gp === 5) room.sendChat(`üëë‚öΩ REPOKER de ${s.name}!`);
  if(gp === 6 || gp === 7 || gp === 8) anunciarGolesEspecialesPorPartido(s.name, gp);

  var ventanaEntreToques = 6000;
  if(
    penultimoTocador &&
    penultimoTocador.team === s.team &&
    penultimoTocador.id !== s.id &&
    penultimoTocadorTime > 0 &&
    (ultimoTocadorTime - penultimoTocadorTime) <= ventanaEntreToques
  ){
    asistencias[penultimoTocador.id] = (asistencias[penultimoTocador.id]||0) + 1;
    asistPartido[penultimoTocador.id] = (asistPartido[penultimoTocador.id]||0) + 1;
    room.sendChat("üéÅ Asistencia de " + penultimoTocador.name);
  }

  if(ultimoGol===s.id){
    racha[s.id] = (racha[s.id]||1) + 1;
    if(racha[s.id]===2) room.sendChat("üî• Est√° en racha!");
  } else {
    ultimoGol = s.id;
    racha[s.id] = 1;
  }
};

// ================= GAME STOP =================
room.onGameStop = function(){
  timeMultiplier = 1;

  if(stopFuePenal){ stopFuePenal = false; return; }
  if(!sistemaActivo) return;
  if(!lastScoreValido) return;

  let s = { blue: lastScore.blue, red: lastScore.red };

  if(fase === "IDA"){
    idaScore.blue = s.blue;
    idaScore.red = s.red;
    idaTermino = true;
    qChat(`üèÅ üîµ IDA ‚Üí ${idaScore.blue} - ${idaScore.red} üî¥ üèÅ`);
    MVP_IDA();

    // ‚úÖ desde aqu√≠ marcamos que en VUELTA ser√° invertido (pero el swap se hace luego)
    vueltaConEquiposInvertidos = true;
    qChat("üîÑ CAMBIO DE ARCO: üîµ‚Üîüî¥ (se invierten equipos)");

    fase = "VUELTA";
    bloqueo = true;

    qChat("‚è≥ Cambio de partido...");
    qChat("üîÅ VUELTA inicia en 3 segundos");

    setTimeout(()=>{
      swapEquipos();
      bloqueo = false;
      room.setScoreLimit(0);
      room.setTimeLimit(0);
      room.startGame();
    }, DELAY_VUELTA_MS);

    return;
  }

  if(fase === "VUELTA"){
    burstChat(`üèÅ üîÅ VUELTA ‚Üí ${s.blue} - ${s.red} üèÅ`);
    MVP_VUELTA();

    let A = serieGoals[1];
    let B = serieGoals[2];

    burstLines([
      decoTop(),
      "üåç RESULTADO GLOBAL (POR GOLES REALES)",
      `${serieLabel[1]} ${A} ‚îÄ ${B} ${serieLabel[2]}`,
      decoBot()
    ]);

    MVP_SERIE();

    if(A > B){
      penalesHabilitados = false;

      burstChat(`üèÜüî• GANADOR GLOBAL: ${serieLabel[1]}`);
      let elegido = randomPlayerFromSerieTeam(1);
      if(elegido) burstChat(`üé≤ SACA A: ${elegido.name}`);

      // ‚úÖ perdedor a spec + capit√°n pierde cargo (SOLO AL FINAL DE LA SERIE)
      moveRealTeamToSpec(2);
      clearCaptain(2);

      burstChat("‚õî SERIE TERMINADA");
      sistemaActivo = false; fase = "FIN";
    } else if(B > A){
      penalesHabilitados = false;

      burstChat(`üèÜüî• GANADOR GLOBAL: ${serieLabel[2]}`);
      let elegido = randomPlayerFromSerieTeam(2);
      if(elegido) burstChat(`üé≤ SACA A: ${elegido.name}`);

      // ‚úÖ perdedor a spec + capit√°n pierde cargo (SOLO AL FINAL DE LA SERIE)
      moveRealTeamToSpec(1);
      clearCaptain(1);

      burstChat("‚õî SERIE TERMINADA");
      sistemaActivo = false; fase = "FIN";
    } else {
      // ‚úÖ empate => nadie pierde capit√°n
      burstChat("ü§ù EMPATE GLOBAL (NO HAY GANADOR)");
      burstChat("üß§ Cada equipo elige su arquero con: !arquero");
      burstChat("üîÅ Si te equivocas: !noarquero");
      burstChat("‚úÖ Cuando est√©n los 2 arqueros, el ADMIN usa: !penal");

      penalesHabilitados = true;
      keeperBlueId = null;
      keeperRedId  = null;
    }
  }
};
// ================= PARTE 2/2 (CORREGIDA) =================
// ‚úÖ P√©gala DESPU√âS de la PARTE 1/2

// ===================================================================
// ===================== PENALES (FIX + REPETIR TIRADOR) ==============
// ===================================================================

var penalActivo = false;
var stopFuePenal = false;

var keeperBlueId = null; // AZUL (team 2 en ese momento)
var keeperRedId  = null; // ROJO (team 1 en ese momento)

var PENAL_BASE_SHOTS = 4;

var penShots = { 1: 0, 2: 0 };
var penGoals = { 1: 0, 2: 0 };
var penTurnTeam = 1;

var penTeamIds = { 1: [], 2: [] };
var penShooters = { 1: [], 2: [] };
var penShooterIdx = { 1: 0, 2: 0 };

var penalOriginalTeams = {};

var penShooterId = null;
var penKeeperId  = null;

var penAttemptLive = false;
var penAttemptStart = 0;
var penShooterKickTime = 0;
var penKeeperTouched = false;

var PENAL_TOUCH_WINDOW_MS = 900;
var lastBallPos = null;
var lastBallMoveTime = 0;
var PENAL_IDLE_MS = 700;
var PENAL_MAX_MS  = 20000;
var BALL_EPS2 = 0.20 * 0.20;
var PENAL_MIN_CHECK_AFTER_KICK_MS = 900;

var penSideFlip = 0;
function mapTeam(logicalTeam){
  return penSideFlip ? (logicalTeam === 1 ? 2 : 1) : logicalTeam;
}

function penPlayerById(id){
  return room.getPlayerList().find(p=>p.id===id) || null;
}
function penIsInFrozenTeam(id, logicalTeam){
  return penTeamIds[logicalTeam].indexOf(id) !== -1;
}
function penBuildFrozenTeams(){
  penTeamIds[1] = room.getPlayerList().filter(p=>p.team===1).map(p=>p.id);
  penTeamIds[2] = room.getPlayerList().filter(p=>p.team===2).map(p=>p.id);
}
function penBuildShootersFromFrozen(){
  penShooters[1] = penTeamIds[1].filter(id => id !== keeperBlueId && id !== keeperRedId);
  penShooters[2] = penTeamIds[2].filter(id => id !== keeperBlueId && id !== keeperRedId);
  penShooterIdx[1] = 0;
  penShooterIdx[2] = 0;
}

// repetir tirador si hay 1
function penNextShooter(logicalTeam, keeperId){
  let arr = penShooters[logicalTeam];
  if(!arr || arr.length === 0) return null;

  let connected = room.getPlayerList().map(p=>p.id);
  let triesMax = arr.length + 10;

  for(let tries=0; tries<triesMax; tries++){
    let id = arr[penShooterIdx[logicalTeam] % arr.length];
    penShooterIdx[logicalTeam]++;

    if(id === keeperId) continue;
    if(id === keeperBlueId || id === keeperRedId) continue;
    if(connected.indexOf(id) === -1) continue;
    if(!penIsInFrozenTeam(id, logicalTeam)) continue;

    return id;
  }
  return null;
}

function penSetOnlyShooterAndKeeper(logicalKickTeam, shooterId, keeperId){
  let kickReal = mapTeam(logicalKickTeam);
  let defReal  = (kickReal === 1 ? 2 : 1);

  room.getPlayerList().forEach(p => room.setPlayerTeam(p.id, 0));
  room.setPlayerTeam(shooterId, kickReal);
  room.setPlayerTeam(keeperId, defReal);
}

function penShowScore(){
  let phase = (penShots[1] >= PENAL_BASE_SHOTS && penShots[2] >= PENAL_BASE_SHOTS) ? "üî• MUERTE S√öBITA" : "üéØ PENALES (4)";
  room.sendChat(`${phase} | üî¥ ${penGoals[1]} (${penShots[1]}) - (${penShots[2]}) ${penGoals[2]} üîµ`);
}

function penEarlyWinner(){
  if(penShots[1] >= PENAL_BASE_SHOTS && penShots[2] >= PENAL_BASE_SHOTS) return 0;

  let rS = penShots[1], bS = penShots[2];
  let rG = penGoals[1], bG = penGoals[2];

  let rRem = Math.max(0, PENAL_BASE_SHOTS - rS);
  let bRem = Math.max(0, PENAL_BASE_SHOTS - bS);

  if(rG > bG + bRem) return 1;
  if(bG > rG + rRem) return 2;
  return 0;
}

function penSuddenDeathWinner(){
  if(penShots[1] === penShots[2] && penShots[1] > PENAL_BASE_SHOTS){
    if(penGoals[1] > penGoals[2]) return 1;
    if(penGoals[2] > penGoals[1]) return 2;
  }
  return 0;
}

function penResetAttemptState(){
  penAttemptLive = true;
  penAttemptStart = Date.now();
  penShooterKickTime = 0;
  penKeeperTouched = false;

  lastBallPos = room.getBallPosition();
  lastBallMoveTime = Date.now();
}

function penAfterAttemptNext(){
  penSideFlip = penSideFlip ? 0 : 1;
  penTurnTeam = (penTurnTeam === 1 ? 2 : 1);
  setTimeout(penStartAttempt, 250);
}

function penFinish(winnerLogicalTeam){
  // restaurar equipos antes de cerrar
  for(let id in penalOriginalTeams) room.setPlayerTeam(Number(id), penalOriginalTeams[id]);

  penalActivo = false;
  penAttemptLive = false;

  room.setScoreLimit(0);
  room.setTimeLimit(0);

  // reset para pr√≥xima tanda
  keeperBlueId = null;
  keeperRedId  = null;
  penSideFlip  = 0;
  penalesHabilitados = false;

  let ganadorFisico = (winnerLogicalTeam === 1) ? "üî¥ ROJO" : "üîµ AZUL";
  burstLines([decoTop(), "üèÅ PENALES TERMINADOS", `üèÜ GANADOR POR PENALES: ${ganadorFisico}`, decoBot()]);

  // ‚úÖ convertir ganador f√≠sico -> ganador REAL (para ‚Äúsaca‚Äù + castigo correcto)
  let winnerReal = physicalToRealTeamNow(winnerLogicalTeam);
  let loserReal  = (winnerReal === 1 ? 2 : 1);

  let elegido = randomPlayerFromSerieTeam(winnerReal);
  if(elegido) burstChat(`üé≤ SACA A: ${elegido.name}`);

  // perdedor real a spec + capit√°n real pierde cargo
  moveRealTeamToSpec(loserReal);
  clearCaptain(loserReal);

  burstChat("‚õî SERIE TERMINADA");
  sistemaActivo = false;
  fase = "FIN";
}

function penResolveAndNext(message){
  if(message) room.sendChat(message);
  penShowScore();

  setTimeout(()=>{
    stopFuePenal = true;
    room.stopGame();

    let early = penEarlyWinner();
    if(early){ penFinish(early); return; }

    if(penShots[1] >= PENAL_BASE_SHOTS && penShots[2] >= PENAL_BASE_SHOTS){
      // si termin√≥ justo el 4/4
      if(penShots[1] === PENAL_BASE_SHOTS && penShots[2] === PENAL_BASE_SHOTS){
        if(penGoals[1] > penGoals[2]) return penFinish(1);
        if(penGoals[2] > penGoals[1]) return penFinish(2);
      }

      // muerte s√∫bita: misma cantidad >4
      let sd = penSuddenDeathWinner();
      if(sd) return penFinish(sd);
    }

    penAfterAttemptNext();
  }, 1000);
}

function penStartAttempt(){
  if(!penalActivo) return;

  let ids = room.getPlayerList().map(p=>p.id);
  if(ids.indexOf(keeperBlueId) === -1 || ids.indexOf(keeperRedId) === -1){
    room.sendChat("‚ö†Ô∏è Se fue un arquero. Vuelvan a elegir con !arquero");
    penalActivo = false;
    for(let id in penalOriginalTeams) room.setPlayerTeam(Number(id), penalOriginalTeams[id]);
    keeperBlueId = null; keeperRedId = null;
    return;
  }

  let logicalKickTeam = penTurnTeam;
  let keeper = (logicalKickTeam === 1 ? keeperBlueId : keeperRedId);

  let shooter = penNextShooter(logicalKickTeam, keeper);
  if(!shooter){
    room.sendChat("‚ö†Ô∏è Ese equipo no tiene tirador (solo arquero).");
    penFinish(logicalKickTeam === 1 ? 2 : 1);
    return;
  }

  penShooterId = shooter;
  penKeeperId  = keeper;

  let sp = penPlayerById(shooter);
  let kp = penPlayerById(keeper);

  let nShot = (logicalKickTeam === 1 ? penShots[1] : penShots[2]) + 1;
  let phaseTxt = (penShots[1] >= PENAL_BASE_SHOTS && penShots[2] >= PENAL_BASE_SHOTS)
    ? "üî• MUERTE S√öBITA"
    : `üéØ Penal ${nShot}/${PENAL_BASE_SHOTS}`;

  qLines([
    decoTop(),
    `${phaseTxt} | Patea ${logicalKickTeam===1 ? "üî¥ ROJO" : "üîµ AZUL"} (bando ${penSideFlip ? "INVERTIDO" : "NORMAL"})`,
    `‚öΩ Tira: ${sp ? sp.name : "?"}`,
    `üß§ Ataja: ${kp ? kp.name : "?"}`,
    decoBot()
  ]);

  stopFuePenal = true;
  room.stopGame();

  setTimeout(()=>{
    penSetOnlyShooterAndKeeper(logicalKickTeam, shooter, keeper);
    room.setScoreLimit(1);
    room.setTimeLimit(0);

    penResetAttemptState();

    stopFuePenal = true;
    room.startGame();
  }, 250);
}

function iniciarPenales(){
  if(!penalesHabilitados){
    room.sendChat("‚ö†Ô∏è Los penales solo se habilitan si el GLOBAL termina empatado.");
    return;
  }

  penBuildFrozenTeams();

  if(penTeamIds[1].length === 0 || penTeamIds[2].length === 0){
    room.sendChat("‚ö†Ô∏è Debe haber jugadores en ROJO y AZUL.");
    return;
  }

  if(!keeperBlueId || !keeperRedId){
    room.sendChat("‚ö†Ô∏è Falta arquero. ROJO y AZUL deben usar !arquero");
    return;
  }
  if(keeperBlueId === keeperRedId){
    room.sendChat("‚ùå No puede ser el MISMO arquero para ambos.");
    return;
  }

  if(!penIsInFrozenTeam(keeperBlueId, 2)){
    room.sendChat("‚ùå El arquero AZUL no est√° en AZUL ahora. Vuelvan a elegir con !arquero");
    return;
  }
  if(!penIsInFrozenTeam(keeperRedId, 1)){
    room.sendChat("‚ùå El arquero ROJO no est√° en ROJO ahora. Vuelvan a elegir con !arquero");
    return;
  }

  penalOriginalTeams = {};
  room.getPlayerList().forEach(p=>{
    if(p.team !== 0) penalOriginalTeams[p.id] = p.team;
  });

  penShots[1]=0; penShots[2]=0;
  penGoals[1]=0; penGoals[2]=0;
  penTurnTeam = 1;
  penSideFlip = 0;

  penBuildShootersFromFrozen();

  if(penShooters[1].length === 0 || penShooters[2].length === 0){
    room.sendChat("‚ö†Ô∏è Cada equipo debe tener AL MENOS 1 tirador (aparte del arquero).");
    return;
  }

  penalActivo = true;
  penalesHabilitados = false;

  var kBlue = penPlayerById(keeperBlueId);
  var kRed  = penPlayerById(keeperRedId);

  qLines([
    decoTop(),
    "üéØ PENALES (4 TIROS C/U)",
    `üß§ Arquero AZUL: ${kBlue ? kBlue.name : "?"}`,
    `üß§ Arquero ROJO: ${kRed ? kRed.name : "?"}`,
    "üìå Patea ROJO primero, luego AZUL",
    "üîÅ Si hay 1 tirador por equipo, se REPITE en sus 4 tiros",
    decoBot()
  ]);

  penStartAttempt();
}

// detector ‚Äúsin gol‚Äù
function penTryResolveMissByBall(){
  if(!penalActivo) return;
  if(!penAttemptLive) return;
  if(penShooterKickTime <= 0) return;

  let now = Date.now();
  if(now - penShooterKickTime < PENAL_MIN_CHECK_AFTER_KICK_MS) return;

  let sc = room.getScores();
  if(sc && (sc.red + sc.blue) > 0) return;

  let bp = room.getBallPosition();

  if(lastBallPos){
    let dx = bp.x - lastBallPos.x;
    let dy = bp.y - lastBallPos.y;
    if((dx*dx + dy*dy) > BALL_EPS2){
      lastBallMoveTime = now;
      lastBallPos = bp;
    }
  } else {
    lastBallPos = bp;
    lastBallMoveTime = now;
  }

  if(now - penAttemptStart > PENAL_MAX_MS){
    lastBallMoveTime = now - PENAL_IDLE_MS - 1;
  }

  if(now - lastBallMoveTime < PENAL_IDLE_MS) return;

  penAttemptLive = false;

  let logicalKickTeam = penTurnTeam;
  penShots[logicalKickTeam]++;

  let kp = penPlayerById(penKeeperId);
  let sp = penPlayerById(penShooterId);

  if(penKeeperTouched) penResolveAndNext(`üß§ ATAJ√ì ${kp ? kp.name : "el arquero"}!`);
  else penResolveAndNext(`‚ùå ERR√ì ${sp ? sp.name : "el tirador"}!`);
}

// ================= CHAT =================
room.onPlayerChat = function(player,msg){
  let A = parseArgs(msg);
  let cmd = A[0] || "";

  // ================== COMANDOS P√öBLICOS ==================
  if(cmd === "!help"){
    cmdHelp(player.id);
    return false;
  }

  if(cmd === "!ida"){
    cmdIda(player.id);
    return false;
  }

  if(cmd === "!global"){
    cmdGlobal(player.id);
    return false;
  }

  if(cmd === "!stats"){
    let name = A.slice(1).join(" ");
    cmdStats(player.id, name);
    return false;
  }

  if(cmd === "!avatar"){
    // !avatar üòé   |   !avatar
    if(A.length === 1){
      setAvatarSafe(player.id, "");
      room.sendChat(`üßë ${player.name} quit√≥ su avatar`);
      return false;
    }

    let av = A[1];

    // limitar longitud (evita spam)
    if(av.length > 2){
      room.sendChat("‚ö†Ô∏è Avatar demasiado largo (m√°x 1‚Äì2 caracteres).");
      return false;
    }

    setAvatarSafe(player.id, av);
    room.sendChat(`üßë ${player.name} cambi√≥ su avatar a ${av}`);
    return false;
  }

  // ================== AUTO-ARQUERO (TODOS) ==================
  if(cmd === "!arquero"){
    if(!penalesHabilitados){
      room.sendChat("‚ö†Ô∏è A√∫n no hay penales habilitados. Solo cuando el GLOBAL empata.");
      return false;
    }
    if(player.team === 0){
      room.sendChat(`‚ùå ${player.name} debes estar en ROJO o AZUL para ser arquero.`);
      return false;
    }

    // AZUL = team 2
    if(player.team === 2){
      if(keeperBlueId === player.id){
        room.sendChat(`üß§ ${player.name} ya eres el arquero AZUL.`);
        return false;
      }
      if(keeperBlueId && keeperBlueId !== player.id){
        let kb = room.getPlayerList().find(p=>p.id===keeperBlueId);
        room.sendChat(`üß§ Ya hay arquero AZUL: ${kb ? kb.name : "?"} (si se equivoc√≥: !noarquero)`);
        return false;
      }
      if(player.id === keeperRedId){
        room.sendChat("‚ùå No puedes ser arquero en ambos equipos.");
        return false;
      }
      keeperBlueId = player.id;
      room.sendChat(`üß§ Arquero AZUL seteado: ${player.name}`);
      return false;
    }

    // ROJO = team 1
    if(player.team === 1){
      if(keeperRedId === player.id){
        room.sendChat(`üß§ ${player.name} ya eres el arquero ROJO.`);
        return false;
      }
      if(keeperRedId && keeperRedId !== player.id){
        let kr = room.getPlayerList().find(p=>p.id===keeperRedId);
        room.sendChat(`üß§ Ya hay arquero ROJO: ${kr ? kr.name : "?"} (si se equivoc√≥: !noarquero)`);
        return false;
      }
      if(player.id === keeperBlueId){
        room.sendChat("‚ùå No puedes ser arquero en ambos equipos.");
        return false;
      }
      keeperRedId = player.id;
      room.sendChat(`üß§ Arquero ROJO seteado: ${player.name}`);
      return false;
    }
  }

  if(cmd === "!noarquero"){
    if(player.id === keeperBlueId){
      keeperBlueId = null;
      room.sendChat(`üß§ ${player.name} dej√≥ de ser arquero AZUL.`);
      return false;
    }
    if(player.id === keeperRedId){
      keeperRedId = null;
      room.sendChat(`üß§ ${player.name} dej√≥ de ser arquero ROJO.`);
      return false;
    }
    room.sendChat("‚ùå No eres arquero.");
    return false;
  }

  // ================== CAMBIO (SOLO CAPITANES) ==================
  let capTeam = captainRealTeamOfPlayer(player);

  if(cmd === "!cambio"){
    if(!sistemaActivo || fase === "FIN"){
      room.sendChat("‚ö†Ô∏è No hay serie activa.");
      return false;
    }
    if(capTeam === 0){
      room.sendChat("‚ùå Solo capitanes pueden usar !cambio.");
      return false;
    }
    if(cambioUsado[capTeam]){
      room.sendChat("‚ùå Ya usaste el √öNICO cambio de tu equipo en esta serie.");
      return false;
    }
    if(penalActivo){
      room.sendChat("‚õî No durante penales.");
      return false;
    }

    if(A.length < 2){
      room.sendChat('Uso: !cambio "Sale" ["Entra"]  (si no pones Entra, entra 1 espectador al azar)');
      return false;
    }

    let outName = A[1];
    let outP = findPlayerByName(outName);
    if(!outP){ room.sendChat("‚ùå No encuentro a: " + outName); return false; }

    // Debe estar jugando (no espectador)
    if(outP.team === 0){
      room.sendChat("‚ùå El que SALE debe estar jugando (no espectador).");
      return false;
    }

    // no permitir sacar al capit√°n
    if(outP.id === capitan[capTeam]){
      room.sendChat("‚ùå No puedes sacarte a ti mismo (capit√°n).");
      return false;
    }

    // Solo puede sacar a alguien de SU equipo real de la serie
    if(serieTeamOf[outP.id] !== capTeam){
      room.sendChat("‚ùå Ese jugador no es de tu equipo (serie).");
      return false;
    }

    let inP = null;
    if(A.length >= 3){
      let inName = A[2];
      inP = findPlayerByName(inName);
      if(!inP){ room.sendChat("‚ùå No encuentro a: " + inName); return false; }
      if(inP.team !== 0){ room.sendChat("‚ùå El que ENTRA debe estar de ESPECTADOR."); return false; }
    } else {
      let specs = room.getPlayerList().filter(p=>p.team===0);
      if(specs.length === 0){ room.sendChat("‚ùå No hay espectadores para entrar."); return false; }
      inP = specs[Math.floor(Math.random()*specs.length)];
    }

    // no permitir meter un capit√°n
    if(inP.id === capitan[1] || inP.id === capitan[2]){
      room.sendChat("‚ùå Ese jugador es capit√°n, no puede entrar por cambio.");
      return false;
    }

    // ‚úÖ Si el partido est√° corriendo, pausamos un toque para que el cambio sea limpio
    let sc = room.getScores();
    let alreadyPaused = enPausa === true;
    if(sc && !alreadyPaused) room.pauseGame(true);

    // ‚úÖ equipo f√≠sico correcto seg√∫n momento (incluye transici√≥n IDA->VUELTA)
    let physTeam = realToPhysicalTeamNow(capTeam);

    room.setPlayerTeam(outP.id, 0);
    room.setPlayerTeam(inP.id, physTeam);

    // actualizar identidad de serie para el GLOBAL
    delete serieTeamOf[outP.id];
    serieTeamOf[inP.id] = capTeam;

    cambioUsado[capTeam] = true;

    room.sendChat(`üîÅ CAMBIO ${capTeam===1?"üî¥":"üîµ"}: SALE ${outP.name} / ENTRA ${inP.name} ‚úÖ (1 cambio usado)`);

    if(sc && !alreadyPaused){
      setTimeout(()=> room.pauseGame(false), 250);
    }

    return false;
  }

  // ================== ADMIN ONLY (TODO LO DEM√ÅS) ==================
  if(!player.admin) return true;

  if(cmd === "!time"){
    if(A.length < 2){
      room.sendChat("Uso: !time x2 | x3 | x4");
      return false;
    }

    let s = room.getScores();
    if(!s){
      room.sendChat("‚ö†Ô∏è No hay partido activo.");
      return false;
    }

    let diff = Math.abs(s.blue - s.red);
    if(diff < 4){
      room.sendChat("‚ö†Ô∏è Solo puedes acelerar si hay diferencia de 4 goles o m√°s.");
      return false;
    }

    let mult = parseInt(A[1].replace("x",""));
    if(![2,3,4].includes(mult)){
      room.sendChat("‚ö†Ô∏è Valores permitidos: x2, x3, x4");
      return false;
    }

    timeMultiplier = mult;
    room.sendChat(`‚è© TIEMPO ACELERADO x${mult}`);
    return false;
  }

  if(cmd === "!timeoff"){
    timeMultiplier = 1;
    room.sendChat("‚è±Ô∏è Tiempo normal restaurado");
    return false;
  }

  // ---------- CAPIT√ÅN / NO CAPIT√ÅN (solo admin) ----------
  if(cmd === "!capitan"){
    if(A.length < 2){ room.sendChat('Uso: !capitan "Nombre exacto"'); return false; }

    let target = findPlayerByName(A[1]);
    if(!target){ room.sendChat("‚ùå Jugador no encontrado"); return false; }
    if(target.team === 0){ room.sendChat("‚ùå Debe estar en ROJO o AZUL."); return false; }

    let realTeam = sistemaActivo
      ? (serieTeamOf[target.id] != null ? serieTeamOf[target.id] : physicalToRealTeamNow(target.team))
      : target.team;

    if(realTeam !== 1 && realTeam !== 2){
      room.sendChat("‚ùå No se pudo determinar el equipo real.");
      return false;
    }

    if(capitan[realTeam] && capitan[realTeam] !== target.id){
      room.sendChat(`‚ùå Ya hay CAPIT√ÅN ${realTeam===1?"ROJO":"AZUL"}: ${getNameById(capitan[realTeam])}`);
      return false;
    }

    if(capitan[1] === target.id && realTeam !== 1) clearCaptain(1);
    if(capitan[2] === target.id && realTeam !== 2) clearCaptain(2);

    setCaptain(realTeam, target.id);
    room.sendChat(`üß¢ Capit√°n ${realTeam===1?"üî¥ ROJO":"üîµ AZUL"} asignado: ${target.name}`);
    return false;
  }

  if(cmd === "!nocapitan"){
    if(A.length < 2){ room.sendChat('Uso: !nocapitan "Nombre exacto"'); return false; }

    let target = findPlayerByName(A[1]);
    if(!target){ room.sendChat("‚ùå Jugador no encontrado (debe estar conectado)."); return false; }

    if(capitan[1] === target.id){ clearCaptain(1); room.sendChat(`üß¢ ${target.name} ya no es CAPIT√ÅN ROJO.`); return false; }
    if(capitan[2] === target.id){ clearCaptain(2); room.sendChat(`üß¢ ${target.name} ya no es CAPIT√ÅN AZUL.`); return false; }

    room.sendChat("‚ùå Ese jugador no es capit√°n.");
    return false;
  }

  // ---------- (manual por si quieres, pero auto-arquero ya existe) ----------
  if(cmd === "!tapa" && A.length >= 2){
    let target = findPlayerByName(A[1]);
    if(!target){ room.sendChat("‚ùå Jugador no encontrado"); return false; }

    if(!keeperBlueId){
      keeperBlueId = target.id;
      room.sendChat(`üß§ Arquero AZUL seteado: ${target.name}`);
    } else if(!keeperRedId){
      if(target.id === keeperBlueId){
        room.sendChat("‚ùå Ese ya es el arquero AZUL. El ROJO debe ser otro.");
        return false;
      }
      keeperRedId = target.id;
      room.sendChat(`üß§ Arquero ROJO seteado: ${target.name}`);
    } else {
      if(target.id === keeperBlueId){
        room.sendChat("‚ùå Ese ya es el arquero AZUL. El ROJO debe ser otro.");
        return false;
      }
      keeperRedId = target.id;
      room.sendChat(`üß§ Arquero ROJO actualizado: ${target.name}`);
    }
    return false;
  }

  if(cmd === "!penal"){
    iniciarPenales();
    return false;
  }

  if(cmd === "!on"){
    // reset penales
    penalActivo = false;
    penAttemptLive = false;
    penalOriginalTeams = {};
    keeperBlueId = null;
    keeperRedId  = null;
    penSideFlip = 0;

    // reset habilitaci√≥n de penales
    penalesHabilitados = false;

    // reset cambios
    cambioUsado = { 1:false, 2:false };

    // ‚úÖ reset serie global
    serieTeamOf = {};
    serieGoals = {1:0, 2:0};
    serieLabel = {1:"üî¥ ROJO (IDA)", 2:"üîµ AZUL (IDA)"};

    // congelar identidad real de cada jugador al prender sistema
    room.getPlayerList().forEach(p=>{
      if(p.team === 1) serieTeamOf[p.id] = 1;
      if(p.team === 2) serieTeamOf[p.id] = 2;
    });

    // ‚úÖ NO borrar capitanes por swap/teams; SOLO si ya no est√°n conectados
    if(capitan[1]){
      let p1 = room.getPlayerList().find(p=>p.id===capitan[1]);
      if(!p1) clearCaptain(1);
    }
    if(capitan[2]){
      let p2 = room.getPlayerList().find(p=>p.id===capitan[2]);
      if(!p2) clearCaptain(2);
    }

    sistemaActivo = true;
    fase = "IDA";
    idaScore = {blue:0, red:0};
    idaTermino = false;

    vueltaConEquiposInvertidos = false;
    bloqueo = false;

    goles={}; asistencias={}; autogoles={}; tiempo={}; racha={};
    ultimoGol=null; ultimoTocador=null; penultimoTocador=null;
    ultimoTocadorTime=0; penultimoTocadorTime=0;

    jugoIda.clear(); jugoVuelta.clear();
    resetPorPartido();

    room.setTimeLimit(0);
    room.setScoreLimit(0);

    qChat("IDA & VUELTA");
    qChat("‚è±Ô∏è Regla: 120s + extra (20/25/30)");
    qChat("üß¢ Capitanes: ADMIN !capitan / !nocapitan | Capitanes: !cambio (1 por serie)");
    qChat("üéØ Penales (solo si GLOBAL empata): !arquero / !noarquero y luego ADMIN: !penal");

    room.stopGame();
    room.startGame();
    return false;
  }

  if(cmd === "!off"){
    sistemaActivo=false;
    penalesHabilitados=false;
    keeperBlueId=null;
    keeperRedId=null;
    idaTermino = false;

    room.sendChat("üîÅ Reinicio cuto de MRD");
    return false;
  }

  return true;
};

// ================= LIMPIAR ARQUEROS/CAPITANES SI SE VAN =================
room.onPlayerLeave = function(p){
  if(p.id === keeperBlueId) keeperBlueId = null;
  if(p.id === keeperRedId)  keeperRedId  = null;

  if(p.id === capitan[1]) clearCaptain(1);
  if(p.id === capitan[2]) clearCaptain(2);
};

// ================= (opcional) si alguien entra a equipo en medio de serie y no estaba mapeado =================
room.onPlayerTeamChange = function(changedPlayer){
  if(!sistemaActivo) return;

  if(changedPlayer.team !== 0 && serieTeamOf[changedPlayer.id] == null){
    serieTeamOf[changedPlayer.id] = physicalToRealTeamNow(changedPlayer.team);
  }
};

room.onPlayerJoin = p=>{

  // si quieres admin especial, lo mantienes igual
  if(p.name==="ELBUENDELIPRIME") room.setPlayerAdmin(p.id,true);

  // bienvenida en 3 mensajes (con delay para que cargue auth)
  setTimeout(()=> sendBienvenida3(p), 700);
};
